clear
clc

V=[10,20,30,40,50,60,70,80]
Fu=[25,70,380,550,610,1220,830,1450]


plot(V,Fu,'ro')


// Definimos la funcion principal para testear los valores obtenidos
deff('Fu_i = F(v, c1, c2)','Fu_i =(c1*v^c2)')


// Definición de la función que calcula el error de predicción cuadratico para un cierto punto (c_i,k_i), en función de los parametros k_max y c_s
deff('y = EC_i(f, v, c1, c2)','y = (f - (c1*v^c2))^2')

// Definimos las formulas para las derivadas parciales.
deff('y = f1(v, c2)','y = v^c2')
deff('y = f2(v, c1, c2)','y = (c1*v^c2*log(v))')

// Definición de las formulas que calculan los terminos de la sumatoria de los elementos del Jacobiano
deff('y = termino_J11_i(k_i,c_i,k_max,c_s)', 'y = (2*c_i^2)/(c_s+c_i)^2')
deff('y = termino_J12_i(k_i,c_i,k_max,c_s)', 'y = (2*c_i*(k_i-(c_i*k_max)/(c_s+c_i)))/(c_s+c_i)^2-(2*c_i^2*k_max)/(c_s+c_i)^3')
deff('y = termino_J21_i(k_i,c_i,k_max,c_s)', 'y = (2*c_i*(k_i-(c_i*k_max)/(c_s+c_i)))/(c_s+c_i)^2-(2*c_i^2*k_max)/(c_s+c_i)^3')
deff('y = termino_J22_i(k_i,c_i,k_max,c_s)', 'y = (2*c_i^2*k_max^2)/(c_s+c_i)^4-(4*c_i*k_max*(k_i-(c_i*k_max)/(c_s+c_i)))/(c_s+c_i)^3')

// Función que calcula las Sumatorias de Errores Cuadraticos
//F(explicada) = matriz de valores medidos de fuerza como resultado del viento.
//X(explicativa) = matriz de valores medidos de velocidad del viento.
//C = matriz de parametros de ajuste.
function S = SEC(F,C,X)
    S = 0			//Suma de errores
    [n,m] =size(F)
    for i=1:n*m
        S=S + EC_i(F(i), X(1), C(1), C(2))
    end
endfunction

// Función que calcula las Sumatorias de los distintos terminos y devuelve el vector F
function V = F(K,C,X)
    k_max = X(1)
    c_s = X(2)
    
    V=[0; 0]
    [n,m] =size(K)
    for i=1:n*m
        V(1)=V(1) + termino_f1(K(i),C(i),k_max,c_s)
        V(2)=V(2) + termino_f2(K(i),C(i),k_max,c_s)
    end
//    disp(V)
endfunction

// Función que calcula las Sumatorias de los distintos terminos y devuelve el jacobiano J
function M = J(K,C,X)
    k_max = X(1)
    c_s = X(2)
    
    M=[0, 0; 0, 0]
    [n,m] =size(K)
    for i=1:n*m
        M(1,1)=M(1,1) + termino_J11_i(K(i),C(i),k_max,c_s)
        M(1,2)=M(1,2) + termino_J12_i(K(i),C(i),k_max,c_s)
        M(2,1)=M(2,1) + termino_J21_i(K(i),C(i),k_max,c_s)
        M(2,2)=M(2,2) + termino_J22_i(K(i),C(i),k_max,c_s)
    end
//    disp(M)
endfunction

// Valor Inicial
X=[15;1]


// Método de Newton-Raphson (modificado)
norma_error_absoluto_max = 0.0000001
N_max = 1000
n=0
norma_error_abs = 1
alpha = 0.01

while (n<N_max) && (norma_error_abs > norma_error_absoluto_max) do
    n=n+1
    disp('***********************')
    X=X-alpha*inv(J(K,C,X))*F(K,C,X)
    
    norma_error_abs = sqrt(sum(F(K,C,X).^2))
    
    disp(X)
    disp(norma_error_abs)
    plot(C,modelo_NL(C,X(1),X(2)),'g--')
    plot(C,K,'ro')
    
end
disp(n)

plot(C,modelo_NL(C,X(1),X(2)),'b')
disp(SEC(K,C,X))